import { getServerSession } from "next-auth"
import { NextRequest, NextResponse } from "next/server"
import { authOptions } from "@/lib/auth"
import { createClient } from "@supabase/supabase-js"

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session || session.user.role !== "admin") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 })
    }

    // Get all active students with comprehensive details
    const { data: students, error } = await supabase
      .from('students')
      .select(`
        student_id,
        first_name,
        middle_name,
        last_name,
        birthday,
        address,
        contact_number,
        created_at,
        updated_at,
        accounts (
          account_id,
          email,
          status
        ),
        sections (
          section_id,
          section_name,
          year_level_id,
          course_id,
          courses (
            course_id,
            course_code,
            course_name,
            departments (
              department_id,
              department_name
            )
          ),
          year_level (
            year_level_id,
            name
          )
        )
      `)
      .order('last_name', { ascending: true })

    if (error) {
      console.error("Database error:", error)
      return NextResponse.json({ error: "Failed to fetch students" }, { status: 500 })
    }

    // Transform the data to match the frontend format
    const transformedStudents = students?.map((student: any) => {
      // Create full name
      const fullName = student.middle_name 
        ? `${student.last_name}, ${student.first_name} ${student.middle_name}`
        : `${student.last_name}, ${student.first_name}`

      // Create year & section display
      const yearSection = `${student.sections?.year_level?.name || 'N/A'} & ${student.sections?.section_name || 'N/A'}`

      // Generate student ID from student_id (assuming it's numeric)
      const studentId = student.student_id.toString().padStart(8, '0')

      // Use status from accounts table directly (active, inactive, suspended)
      const status = student.accounts?.status || "active"

      // Create school year (this would typically come from semester data)
      // For now, we'll use current year as placeholder
      const currentYear = new Date().getFullYear()
      const schoolYear = `${currentYear}-${currentYear + 1} / 1st Semester`

      return {
        id: studentId,
        name: fullName,
        email: student.accounts?.email || 'N/A',
        course: student.sections?.courses?.course_name || 'N/A',
        schoolYear: schoolYear,
        yearSection: yearSection,
        status: status,
        avatar: "/placeholder.svg?height=40&width=40",
        // Additional fields for internal use
        student_id: student.student_id,
        account_id: student.accounts?.account_id || 0,
        section_id: student.sections?.section_id || 0,
        course_id: student.sections?.courses?.course_id || 0,
        department_id: student.sections?.courses?.departments?.department_id || 0,
        birthday: student.birthday,
        address: student.address,
        contact_number: student.contact_number,
        created_at: student.created_at,
        updated_at: student.updated_at
      }
    }) || []

    return NextResponse.json({ students: transformedStudents })
  } catch (error) {
    console.error("API error:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session || session.user.role !== "admin") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 })
    }

    const body = await request.json()
    const {
      // Optional: studentId was previously provided by UI; now auto-generated by DB
      studentId,
      firstName,
      middleName,
      lastName,
      email,
      password,
      course,
      schoolYear,
      yearLevel,
      section,
      status,
      gwa,
      birthday,
      address,
      contactNumber,
      // Prefer ID-based fields when present
      courseId,
      yearLevelId,
      sectionId,
    } = body

    // Validate required fields (studentId no longer required)
    if (!firstName || !lastName || !email || (!course && !courseId) || (!yearLevel && !yearLevelId) || (!section && !sectionId)) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }

    // Start transaction - create account first, then student
    // Hash password (fallback to generated or default if empty)
    let passwordHash = password || 'default_password'
    try {
      const bcrypt = await import('bcryptjs')
      passwordHash = await bcrypt.default.hash(passwordHash, 12)
    } catch (e) {
      // If hashing fails for any reason, proceed with given string (not ideal but non-blocking)
    }
    // Validate status is one of the allowed values
    const validStatuses = ['active', 'inactive', 'suspended']
    const accountStatus = validStatuses.includes(status?.toLowerCase()) ? status.toLowerCase() : 'active'
    
    const { data: account, error: accountError } = await supabase
      .from('accounts')
      .insert({
        email,
        password_hash: passwordHash,
        role: 'student',
        status: accountStatus
      })
      .select('account_id')
      .single()

    if (accountError) {
      console.error("Account creation error:", accountError)
      return NextResponse.json({ error: "Failed to create account" }, { status: 500 })
    }

    // Resolve IDs: prefer provided IDs; fall back to lookup by names
    let resolvedCourseId: number | null = null
    let resolvedDepartmentId: number | null = null
    let resolvedYearLevelId: number | null = null
    let resolvedSectionId: number | null = null

    if (courseId) {
      resolvedCourseId = parseInt(courseId)
      const { data: courseRow } = await supabase
        .from('courses')
        .select('course_id, department_id')
        .eq('course_id', resolvedCourseId)
        .single()
      resolvedDepartmentId = courseRow?.department_id ?? null
    } else {
      const { data: courseData, error: courseError } = await supabase
        .from('courses')
        .select('course_id, department_id')
        .eq('course_name', course)
        .single()
      if (courseError || !courseData) {
        console.error("Course lookup error:", courseError)
        return NextResponse.json({ error: "Invalid course" }, { status: 400 })
      }
      resolvedCourseId = courseData.course_id
      resolvedDepartmentId = courseData.department_id
    }

    // Prefer deriving from sectionId when provided (avoids fragile name matching)
    if (sectionId) {
      resolvedSectionId = parseInt(sectionId)
      const { data: sectionRow, error: sectionByIdError } = await supabase
        .from('sections')
        .select('section_id, year_level_id, course_id')
        .eq('section_id', resolvedSectionId)
        .single()
      if (sectionByIdError || !sectionRow) {
        console.error("Section lookup error:", sectionByIdError)
        return NextResponse.json({ error: "Invalid section" }, { status: 400 })
      }
      resolvedYearLevelId = sectionRow.year_level_id
      // Ensure course alignment from section
      resolvedCourseId = sectionRow.course_id
    } else {
      // No sectionId; resolve yearLevel then section by name
      if (yearLevelId) {
        resolvedYearLevelId = parseInt(yearLevelId)
      } else {
        const { data: yearLevelData, error: yearLevelError } = await supabase
          .from('year_level')
          .select('year_level_id')
          .eq('name', yearLevel)
          .single()
        if (yearLevelError || !yearLevelData) {
          console.error("Year level lookup error:", yearLevelError)
          return NextResponse.json({ error: "Invalid year level" }, { status: 400 })
        }
        resolvedYearLevelId = yearLevelData.year_level_id
      }

      const { data: sectionData, error: sectionError } = await supabase
        .from('sections')
        .select('section_id')
        .eq('section_name', section)
        .eq('year_level_id', resolvedYearLevelId!)
        .eq('course_id', resolvedCourseId!)
        .single()
      if (sectionError || !sectionData) {
        console.error("Section lookup error:", sectionError)
        return NextResponse.json({ error: "Invalid section" }, { status: 400 })
      }
      resolvedSectionId = sectionData.section_id
    }

    // Create student record
    const { data: student, error: studentError } = await supabase
      .from('students')
      .insert({
        account_id: account.account_id,
        first_name: firstName,
        middle_name: middleName || null,
        last_name: lastName,
        // Store as DATE string (YYYY-MM-DD) if provided
        birthday: birthday || null,
        address: address || null,
        contact_number: contactNumber || null,
        section_id: resolvedSectionId!
      })
      .select('*')
      .single()

    if (studentError) {
      console.error("Student creation error:", studentError)
      // Clean up account if student creation fails
      await supabase.from('accounts').delete().eq('account_id', account.account_id)
      return NextResponse.json({ error: "Failed to create student" }, { status: 500 })
    }

    return NextResponse.json({ 
      message: "Student created successfully",
      student: {
        id: student.student_id.toString().padStart(8, '0'),
        name: `${lastName}, ${firstName}${middleName ? ` ${middleName}` : ''}`,
        email,
        course,
        schoolYear,
        yearSection: `${yearLevel} & ${section}`,
        status,
        avatar: "/placeholder.svg?height=40&width=40",
        student_id: student.student_id,
        account_id: account.account_id,
        section_id: resolvedSectionId,
        course_id: resolvedCourseId,
        department_id: resolvedDepartmentId,
        birthday: birthday || null,
        address: address || null,
        contact_number: contactNumber || null,
        created_at: student.created_at,
        updated_at: student.updated_at
      }
    })
  } catch (error) {
    console.error("API error:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session || session.user.role !== "admin") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 })
    }

    const body = await request.json()
    const {
      student_id,
      firstName,
      middleName,
      lastName,
      email,
      password,
      course,
      schoolYear,
      yearLevel,
      section,
      status,
      birthday,
      address,
      contactNumber,
      // Optional ID-based fields for precise updates
      courseId,
      yearLevelId,
      sectionId,
    } = body

    // Validate required fields (allow either IDs or names)
    if (!student_id || !firstName || !lastName || !email || (!course && !courseId) || (!yearLevel && !yearLevelId) || (!section && !sectionId)) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }

    // Get the current student data to find account_id
    const { data: currentStudent, error: studentError } = await supabase
      .from('students')
      .select('account_id')
      .eq('student_id', student_id)
      .single()

    if (studentError || !currentStudent) {
      console.error("Student lookup error:", studentError)
      return NextResponse.json({ error: "Student not found" }, { status: 404 })
    }

    // Update account information
    // Validate status is one of the allowed values
    const validStatuses = ['active', 'inactive', 'suspended']
    const accountStatus = validStatuses.includes(status?.toLowerCase()) ? status.toLowerCase() : 'active'
    
    const accountUpdateData: any = {
      email,
      status: accountStatus
    }

    // Only update password if provided; hash it
    if (password && password.trim() !== '') {
      try {
        const bcrypt = await import('bcryptjs')
        accountUpdateData.password_hash = await bcrypt.default.hash(password, 12)
      } catch (e) {
        accountUpdateData.password_hash = password
      }
    }

    const { error: accountError } = await supabase
      .from('accounts')
      .update(accountUpdateData)
      .eq('account_id', currentStudent.account_id)

    if (accountError) {
      console.error("Account update error:", accountError)
      return NextResponse.json({ error: "Failed to update account" }, { status: 500 })
    }

    // Resolve IDs for course/yearLevel/section
    let resolvedCourseId: number | null = null
    let resolvedDepartmentId: number | null = null
    let resolvedYearLevelId: number | null = null
    let resolvedSectionId: number | null = null

    // Prefer deriving all from sectionId when provided to avoid fragile name matching
    if (sectionId) {
      resolvedSectionId = parseInt(sectionId)
      const { data: sectionRow, error: sectionByIdError } = await supabase
        .from('sections')
        .select('section_id, year_level_id, course_id')
        .eq('section_id', resolvedSectionId)
        .single()
      if (sectionByIdError || !sectionRow) {
        console.error("Section lookup error:", sectionByIdError)
        return NextResponse.json({ error: "Invalid section" }, { status: 400 })
      }
      resolvedYearLevelId = sectionRow.year_level_id
      resolvedCourseId = sectionRow.course_id
      // Optionally resolve department for response consistency
      const { data: courseRow } = await supabase
        .from('courses')
        .select('department_id')
        .eq('course_id', resolvedCourseId)
        .single()
      resolvedDepartmentId = courseRow?.department_id ?? null
    } else {
      // No sectionId: resolve course then year level then section via names/ids
      if (courseId) {
        resolvedCourseId = parseInt(courseId)
        const { data: courseRow } = await supabase
          .from('courses')
          .select('course_id, department_id')
          .eq('course_id', resolvedCourseId)
          .single()
        resolvedDepartmentId = courseRow?.department_id ?? null
      } else {
        const { data: courseData, error: courseError } = await supabase
          .from('courses')
          .select('course_id, department_id')
          .eq('course_name', course)
          .single()
        if (courseError || !courseData) {
          console.error("Course lookup error:", courseError)
          return NextResponse.json({ error: "Invalid course" }, { status: 400 })
        }
        resolvedCourseId = courseData.course_id
        resolvedDepartmentId = courseData.department_id
      }

      if (yearLevelId) {
        resolvedYearLevelId = parseInt(yearLevelId)
      } else {
        const { data: yearLevelData, error: yearLevelError } = await supabase
          .from('year_level')
          .select('year_level_id')
          .eq('name', yearLevel)
          .single()
        if (yearLevelError || !yearLevelData) {
          console.error("Year level lookup error:", yearLevelError)
          return NextResponse.json({ error: "Invalid year level" }, { status: 400 })
        }
        resolvedYearLevelId = yearLevelData.year_level_id
      }

      const { data: sectionData, error: sectionError } = await supabase
        .from('sections')
        .select('section_id')
        .eq('section_name', section)
        .eq('year_level_id', resolvedYearLevelId!)
        .eq('course_id', resolvedCourseId!)
        .single()
      if (sectionError || !sectionData) {
        console.error("Section lookup error:", sectionError)
        return NextResponse.json({ error: "Invalid section" }, { status: 400 })
      }
      resolvedSectionId = sectionData.section_id
    }

    // Update student record
    const { data: student, error: studentUpdateError } = await supabase
      .from('students')
      .update({
        first_name: firstName,
        middle_name: middleName || null,
        last_name: lastName,
        // Store birthday as DATE string when provided
        birthday: birthday || null,
        address: address || null,
        contact_number: contactNumber || null,
        section_id: resolvedSectionId!
      })
      .eq('student_id', student_id)
      .select('*')
      .single()

    if (studentUpdateError) {
      console.error("Student update error:", studentUpdateError)
      return NextResponse.json({ error: "Failed to update student" }, { status: 500 })
    }

    return NextResponse.json({ 
      message: "Student updated successfully",
      student: {
        id: student_id.toString().padStart(8, '0'),
        name: `${lastName}, ${firstName}${middleName ? ` ${middleName}` : ''}`,
        email,
        course,
        schoolYear,
        yearSection: `${yearLevel} & ${section}`,
        status,
        avatar: "/placeholder.svg?height=40&width=40",
        student_id: student.student_id,
        account_id: currentStudent.account_id,
        section_id: resolvedSectionId,
        course_id: resolvedCourseId,
        department_id: resolvedDepartmentId ?? 0,
        birthday: birthday || null,
        address: address || null,
        contact_number: contactNumber || null,
        created_at: student.created_at,
        updated_at: student.updated_at
      }
    })
  } catch (error) {
    console.error("API error:", error)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}