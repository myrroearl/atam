import { getServerSession } from "next-auth"
import { NextRequest, NextResponse } from "next/server"
import { authOptions } from "@/lib/auth"
import { createClient } from "@supabase/supabase-js"
import { 
  logGradeEntryCreation, 
  logGradeEntryUpdate, 
  logGradeEntryDeletion,
  logScoreChanges,
  getProfessorAccountId,
  getComponentName,
  getStudentNames,
  type GradeEntryActivityData
} from "@/lib/activity-logger"

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session || session.user.role !== "professor") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 })
    }

    const body = await request.json()
    const {
      class_id,
      component_id,
      students, // Array of student IDs
      name,
      date_recorded,
      max_score,
      grade_period,
      is_attendance,
      topics // Array of topics
    } = body

    // Validation
    if (!class_id || !component_id || !students || students.length === 0 || !name || !date_recorded || !grade_period) {
      return NextResponse.json({ 
        error: "Missing required fields: class_id, component_id, students, name, date_recorded, grade_period" 
      }, { status: 400 })
    }

    if (!is_attendance && !max_score) {
      return NextResponse.json({ 
        error: "max_score is required for non-attendance components" 
      }, { status: 400 })
    }

    // Prepare grade entries for all students
    const gradeEntries = students.map((student_id: number) => {
      // Create base entry object - NEVER include grade_id (auto-generated by database)
      const entry: Record<string, any> = {
        class_id: Number(class_id),
        component_id: Number(component_id),
        student_id: Number(student_id),
        name: String(name),
        date_recorded: new Date(date_recorded).toISOString(),
        grade_period: String(grade_period),
        entry_type: 'manual entry',
        topics: Array.isArray(topics) ? topics : []
        // Don't include grade_id or created_at - let database handle these
      }

      if (is_attendance) {
        // ðŸ§¾ ATTENDANCE LOGIC
        // Default to null (not marked yet)
        entry.attendance = null
        entry.score = 0
        entry.max_score = 10
      } else {
        // ðŸ§® OTHER GRADING COMPONENTS LOGIC
        // Initialize with 0 score
        entry.score = 0
        entry.max_score = Number(max_score)
        entry.attendance = null
      }

      return entry
    })

    // Insert all grade entries in batch
    const { data, error } = await supabase
      .from('grade_entries')
      .insert(gradeEntries)
      .select()

    if (error) {
      console.error("Database insert error:", error)
      console.error("Attempted to insert:", gradeEntries)
      return NextResponse.json({ 
        error: "Failed to insert grade entries", 
        details: error.message,
        hint: error.hint,
        code: error.code
      }, { status: 500 })
    }

    // Log the activity
    try {
      const accountId = await getProfessorAccountId(session)
      const componentName = await getComponentName(component_id)
      const studentNames = await getStudentNames(students)

      if (accountId) {
        const activityData: GradeEntryActivityData = {
          class_id: Number(class_id),
          component_id: Number(component_id),
          component_name: componentName || undefined,
          grade_period: grade_period || undefined,
          entry_name: name,
          student_count: students.length,
          student_names: studentNames,
          topics: Array.isArray(topics) ? topics : []
        }

        await logGradeEntryCreation(accountId, activityData)
      }
    } catch (logError) {
      console.error("Failed to log grade entry creation activity:", logError)
      // Don't fail the request if logging fails
    }

    return NextResponse.json({ 
      success: true, 
      message: `Successfully created grade entries for ${students.length} student(s)`,
      data 
    }, { status: 201 })

  } catch (error) {
    console.error("API error:", error)
    return NextResponse.json({ 
      error: "Internal server error",
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

// PUT endpoint to update individual student scores or grade entry headers
export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session || session.user.role !== "professor") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 })
    }

    const body = await request.json()
    const {
      grade_id,
      score,
      is_attendance,
      // New fields for editing grade entry headers
      name,
      date_recorded,
      max_score,
      update_type, // 'score' or 'header'
      topics, // Array of topics for header updates
      skip_individual_logging // Flag to skip individual logging when part of bulk operation
    } = body

    // Validation
    if (!grade_id) {
      return NextResponse.json({ 
        error: "Missing required field: grade_id" 
      }, { status: 400 })
    }

    // Handle different update types
    if (update_type === 'header') {
      // Update grade entry header (name, date, max_score)
      if (!name || !date_recorded) {
        return NextResponse.json({ 
          error: "Missing required fields for header update: name, date_recorded" 
        }, { status: 400 })
      }

      const updateData: any = {
        name: String(name),
        date_recorded: new Date(date_recorded).toISOString(),
        topics: Array.isArray(topics) ? topics : []
      }

      // Only update max_score for non-attendance components
      if (max_score !== undefined && max_score !== null && !is_attendance) {
        updateData.max_score = Number(max_score)
      }

      // Fetch the existing entry to determine the header group
      const { data: existingEntry } = await supabase
        .from('grade_entries')
        .select('component_id, name, date_recorded, grade_period')
        .eq('grade_id', grade_id)
        .single()

      if (!existingEntry) {
        return NextResponse.json({ 
          error: "Grade entry not found" 
        }, { status: 404 })
      }

      // Build an update query matching the same header group by component, calendar day, period, and name (with null handling)
      const startOfDay = new Date(existingEntry.date_recorded)
      startOfDay.setUTCHours(0, 0, 0, 0)
      const endOfDay = new Date(startOfDay)
      endOfDay.setUTCDate(endOfDay.getUTCDate() + 1)

      let updateQuery = supabase
        .from('grade_entries')
        .update(updateData)
        .eq('component_id', existingEntry.component_id)
        .gte('date_recorded', startOfDay.toISOString())
        .lt('date_recorded', endOfDay.toISOString())

      if (existingEntry.grade_period !== null) {
        updateQuery = updateQuery.eq('grade_period', existingEntry.grade_period)
      } else {
        updateQuery = updateQuery.is('grade_period', null)
      }

      if (existingEntry.name !== null) {
        updateQuery = updateQuery.eq('name', existingEntry.name)
      } else {
        updateQuery = updateQuery.is('name', null)
      }

      const { data, error } = await updateQuery.select()

      if (error) {
        console.error("Database update error:", error)
        return NextResponse.json({ 
          error: "Failed to update grade entry header", 
          details: error.message 
        }, { status: 500 })
      }

      // Log the activity
      try {
        const accountId = await getProfessorAccountId(session)
        const componentName = await getComponentName(existingEntry.component_id)

        if (accountId) {
        const activityData: GradeEntryActivityData = {
          class_id: 0, // We don't have class_id in this context, but it's not critical for logging
          component_id: existingEntry.component_id,
          component_name: componentName || undefined,
          grade_period: existingEntry.grade_period || undefined,
            entry_name: name,
            student_count: data?.length || 0,
            old_value: {
              name: existingEntry.name,
              date_recorded: existingEntry.date_recorded
            },
            new_value: {
              name: name,
              date_recorded: date_recorded,
              max_score: max_score,
              topics: Array.isArray(topics) ? topics : []
            },
            topics: Array.isArray(topics) ? topics : []
          }

          await logGradeEntryUpdate(accountId, activityData)
        }
      } catch (logError) {
        console.error("Failed to log grade entry update activity:", logError)
        // Don't fail the request if logging fails
      }

      return NextResponse.json({ 
        success: true, 
        message: "Grade entry header updated successfully",
        data 
      }, { status: 200 })

    } else {
      // Original score update logic
      if (score === undefined || score === null) {
        return NextResponse.json({ 
          error: "Missing required fields: score" 
        }, { status: 400 })
      }

      // Prepare update object
      const updateData: any = {
        score
      }

      // Update attendance status based on score
      // For attendance components: 10=present, 5=late, 0=absent
      // For other components: score > 0 = present, score = 0 = absent
      if (score >= 10) {
        updateData.attendance = 'present'
      } else if (score >= 5 && score < 10) {
        updateData.attendance = 'late'
      } else {
        updateData.attendance = 'absent'
      }

      // Get the existing entry details for logging
      const { data: existingEntry, error: fetchError } = await supabase
        .from('grade_entries')
        .select('student_id, component_id, name, score, attendance')
        .eq('grade_id', grade_id)
        .single()

      if (fetchError || !existingEntry) {
        console.error("Failed to fetch existing entry for logging:", fetchError)
      }

      // Update the grade entry
      const { data, error } = await supabase
        .from('grade_entries')
        .update(updateData)
        .eq('grade_id', grade_id)
        .select()

      if (error) {
        console.error("Database update error:", error)
        return NextResponse.json({ 
          error: "Failed to update grade entry", 
          details: error.message 
        }, { status: 500 })
      }

      // Log individual score changes only if not part of a bulk operation
      if (!skip_individual_logging) {
        try {
          const accountId = await getProfessorAccountId(session)
          const componentName = await getComponentName(existingEntry?.component_id || 0)
          const studentNames = existingEntry?.student_id ? await getStudentNames([existingEntry.student_id]) : []

          if (accountId && existingEntry) {
            const activityData: GradeEntryActivityData = {
              class_id: 0, // We don't have class_id in this context
              component_id: existingEntry.component_id,
              component_name: componentName || undefined,
              entry_name: existingEntry.name,
              student_count: 1,
              score_changes: [{
                student_id: existingEntry.student_id,
                student_name: studentNames[0] || `Student ${existingEntry.student_id}`,
                old_score: existingEntry.score || 0,
                new_score: score,
                entry_name: existingEntry.name || 'Unknown Entry'
              }]
            }

            await logScoreChanges(accountId, activityData)
          }
        } catch (logError) {
          console.error("Failed to log individual score change activity:", logError)
          // Don't fail the request if logging fails
        }
      }

      return NextResponse.json({ 
        success: true, 
        message: "Grade entry updated successfully",
        data 
      }, { status: 200 })
    }

  } catch (error) {
    console.error("API error:", error)
    return NextResponse.json({ 
      error: "Internal server error",
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

// DELETE endpoint to remove grade entry headers
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session || session.user.role !== "professor") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const grade_id = searchParams.get('grade_id')

    // Validation
    if (!grade_id) {
      return NextResponse.json({ 
        error: "Missing required parameter: grade_id" 
      }, { status: 400 })
    }

    // Get the entry details to find all related entries
    const { data: existingEntry, error: fetchError } = await supabase
      .from('grade_entries')
      .select('component_id, name, date_recorded, grade_period')
      .eq('grade_id', grade_id)
      .single()

    if (fetchError || !existingEntry) {
      return NextResponse.json({ 
        error: "Grade entry not found" 
      }, { status: 404 })
    }

    // Build a deletion query that matches entries in the same header group.
    // We match by component_id, grade_period, and the same calendar day for date_recorded.
    // If name is null (common for Google Classroom imports), use IS NULL; otherwise match exact name.
    const startOfDay = new Date(existingEntry.date_recorded)
    startOfDay.setUTCHours(0, 0, 0, 0)
    const endOfDay = new Date(startOfDay)
    endOfDay.setUTCDate(endOfDay.getUTCDate() + 1)

    let deleteQuery = supabase
      .from('grade_entries')
      .delete()
      .eq('component_id', existingEntry.component_id)
      .gte('date_recorded', startOfDay.toISOString())
      .lt('date_recorded', endOfDay.toISOString())

    if (existingEntry.grade_period !== null) {
      deleteQuery = deleteQuery.eq('grade_period', existingEntry.grade_period)
    } else {
      deleteQuery = deleteQuery.is('grade_period', null)
    }

    if (existingEntry.name !== null) {
      deleteQuery = deleteQuery.eq('name', existingEntry.name)
    } else {
      deleteQuery = deleteQuery.is('name', null)
    }

    const { data, error } = await deleteQuery.select()

    if (error) {
      console.error("Database delete error:", error)
      return NextResponse.json({ 
        error: "Failed to delete grade entries", 
        details: error.message 
      }, { status: 500 })
    }

    // Log the activity
    try {
      const accountId = await getProfessorAccountId(session)
      const componentName = await getComponentName(existingEntry.component_id)
      const studentIds = data?.map(entry => entry.student_id) || []
      const studentNames = await getStudentNames(studentIds)

      if (accountId) {
        const activityData: GradeEntryActivityData = {
          class_id: 0, // We don't have class_id in this context
          component_id: existingEntry.component_id,
          component_name: componentName || undefined,
          grade_period: existingEntry.grade_period || undefined,
          entry_name: existingEntry.name,
          student_count: data?.length || 0,
          student_names: studentNames
        }

        await logGradeEntryDeletion(accountId, activityData)
      }
    } catch (logError) {
      console.error("Failed to log grade entry deletion activity:", logError)
      // Don't fail the request if logging fails
    }

    return NextResponse.json({ 
      success: true, 
      message: `Successfully deleted grade entries for "${existingEntry.name}"`,
      deletedCount: data?.length || 0,
      data 
    }, { status: 200 })

  } catch (error) {
    console.error("API error:", error)
    return NextResponse.json({ 
      error: "Internal server error",
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}

